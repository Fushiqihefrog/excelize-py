"""Copyright 2024 The excelize Authors. All rights reserved. Use of this source
code is governed by a BSD-style license that can be found in the LICENSE file.

Package excelize-py is a Python port of Go Excelize library, providing a set of
functions that allow you to write and read from XLAM / XLSM / XLSX / XLTM / XLTX
files. Supports reading and writing spreadsheet documents generated by Microsoft
Excelâ„¢ 2007 and later. Supports complex components by high compatibility, and
provided streaming API for generating or reading data from a worksheet with huge
amounts of data. This library needs Python version 3.9 or later.
"""

from dataclasses import fields
from datetime import datetime, date, time
from enum import Enum
from typing import Tuple, get_args, get_origin, List, Optional, Union
import types_go
from types_py import *
from ctypes import (
    byref,
    c_char_p,
    c_char,
    c_int,
    c_ubyte,
    cast,
    CDLL,
    create_string_buffer,
    POINTER,
    pointer,
    string_at,
)
import os
import platform


def load_lib():
    system = platform.system().lower()
    arch = platform.architecture()[0]
    machine = platform.machine().lower()
    ext_map = {"linux": ".so", "darwin": ".dylib", "windows": ".dll"}
    arch_map = {
        "linux": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "aarch64": "arm64",
            },
            "32bit": {
                "x86": "386",
                "i386": "386",
                "i686": "386",
            },
        },
        "darwin": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "arm64": "arm64",
            },
        },
        "windows": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "arm64": "arm64",
            },
            "32bit": {
                "x86": "386",
                "i386": "386",
                "i686": "386",
            },
        },
    }
    if system in ext_map and arch in arch_map.get(system, {}):
        arch_name = arch_map[system][arch].get(machine)
        if arch_name:
            return f"libexcelize.{arch_name}.{system}{ext_map[system]}"

    print("This platform or architecture is not supported.")
    exit(1)


lib = CDLL(os.path.join(os.path.dirname(__file__), load_lib()))
ENCODE = "utf-8"
__version__ = "0.0.2"
uppercase_words = ["id", "xml"]


def py_to_base_ctype(py_value, c_type):
    """
    Convert a Python value to a specified C type.

    Args:
        py_value: The Python value to be converted. If the value is a string, it will be encoded.
        c_type: The target C type to which the Python value should be converted.

    Returns:
        The converted value in the specified C type.
    """
    return (
        c_type(py_value.encode(ENCODE)) if str is type(py_value) else c_type(py_value)
    )


def is_py_primitive_type(t: type) -> bool:
    """
    Check if the given type is a Python primitive type.

    Args:
        t (type): The type to check.

    Returns:
        bool: True if the type is a Python primitive type or an Enum subclass, False otherwise.
    """
    return True if issubclass(t, Enum) else t in {int, float, bool, str, bytes, complex}


def snake_to_pascal(snake_str: str) -> str:
    """
    Convert a snake_case string to PascalCase.

    Args:
        snake_str (str): The snake_case string to convert.

    Returns:
        str: The converted PascalCase string.
    """
    return "".join(
        word.upper() if word.lower() in uppercase_words else word.capitalize()
        for word in snake_str.split("_")
    )


def c_value_to_py(ctypes_instance, py_instance):
    """
    Convert a ctypes instance to a Python instance by mapping fields from the
    to the corresponding fields in the Python instance.

    Args:
        ctypes_instance: The ctypes instance representing the Go data structure.
        py_instance: The Python instance to populate with data from the ctypes instance.

    Returns:
        The populated Python instance, or None if the ctypes instance is None.
    """
    if ctypes_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if type(None) not in py_field_args:
            if is_py_primitive_type(py_field.type):
                c_val = getattr(ctypes_instance, c_field_name)
                if c_val:
                    setattr(
                        py_instance,
                        py_field_name,
                        (c_val.decode(ENCODE) if str is py_field.type else c_val),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                setattr(
                    py_instance,
                    py_field_name,
                    c_value_to_py(
                        getattr(ctypes_instance, c_field_name), py_field.type()
                    ),
                )
        else:
            if get_origin(py_field_args[0]) is not list:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(ctypes_instance, c_field_name)
                if value:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        value = getattr(ctypes_instance, c_field_name)
                        setattr(
                            py_instance,
                            py_field_name,
                            (
                                value.contents.value.decode(ENCODE)
                                if str in py_field_args
                                else value.contents.value
                            ),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            py_instance,
                            py_field_name,
                            c_value_to_py(
                                value.contents,
                                py_field_args[0](),
                            ),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                if type(None) not in get_args(get_args(py_field_args[0])[0]):
                    # The Go data type array, for example: []excelize.Options or []string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(get_args(py_field_args[0])[0]):
                            # The Go basic data type array, for example: []string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(py_field_args[0])[0]
                                    else c_array[i]
                                )
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i],
                                        get_args(py_field_args[0])[0](),
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
                else:
                    # Pointer array of the Go data type, for example: []*excelize.Options or []*string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(
                            get_args(get_args(py_field_args[0])[0])[0]
                        ):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(get_args(py_field_args[0])[0])[0]
                                    else c_array[i].contents.value
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i].contents,
                                        get_args(get_args(py_field_args[0])[0])[0](),
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
    return py_instance


def get_c_field_type(struct, field_name):
    """
    Retrieve the type of a specified field from a C structure.

    Args:
        struct (ctypes.Structure): The C structure containing the fields.
        field_name (str): The name of the field whose type is to be retrieved.

    Returns:
        type: The type of the specified field if found, otherwise None.
    """
    for field in struct._fields_:
        if field[0] == field_name:
            return field[1]


def py_value_to_c(py_instance, ctypes_instance):
    """
    Converts a Python instance to a corresponding C instance using ctypes.

    This function recursively converts fields of a Python instance to their
    corresponding C types and assigns them to the provided ctypes instance.
    It handles primitive types, structs, pointers, and arrays.

    Args:
        py_instance (object): The Python instance to be converted.
        ctypes_instance (ctypes.Structure): The ctypes instance to which the
            converted values will be assigned.

    Returns:
        ctypes.Structure: The ctypes instance with the converted values from
            the Python instance.
    """
    if py_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if type(None) not in py_field_args:
            if is_py_primitive_type(py_field.type):
                if hasattr(py_instance, py_field_name):
                    c_type = get_c_field_type(ctypes_instance, c_field_name)
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_to_base_ctype(getattr(py_instance, py_field_name), c_type),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                c_type = get_c_field_type(ctypes_instance, c_field_name)
                if hasattr(py_instance, py_field_name):
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_value_to_c(getattr(py_instance, py_field_name), c_type()),
                    )
        else:
            if get_origin(py_field_args[0]) is not list:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(py_instance, py_field_name)
                c_type = get_c_field_type(ctypes_instance, c_field_name)._type_
                if value:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_to_base_ctype(value, c_type)),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_value_to_c(value, c_type())),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                py_field_type = get_args(py_field_args[0])[0]
                if type(None) not in get_args(py_field_type):
                    # The Go data type array, for example: []excelize.Options or []string
                    c_type = get_c_field_type(ctypes_instance, c_field_name)._type_
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (c_type * l)()
                        if is_py_primitive_type(py_field_type):
                            # The Go basic data type array, for example: []string
                            if str is py_field_type:
                                c_array_type = POINTER(c_char) * l
                                ctypes_instance.__setattr__(
                                    c_field_name,
                                    c_array_type(
                                        *[
                                            create_string_buffer(c.encode(ENCODE))
                                            for c in py_list
                                        ]
                                    ),
                                )
                            else:
                                for i in range(l):
                                    c_array.__setitem__(
                                        i, py_to_base_ctype(py_list[i], c_type)
                                    )
                                ctypes_instance.__setattr__(c_field_name, c_array)
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                c_array.__setitem__(
                                    i, py_value_to_c(py_list[i], c_type())
                                )
                            ctypes_instance.__setattr__(c_field_name, c_array)
                        ctypes_instance.__setattr__(c_field_name + "Len", c_int(l))

                else:
                    # Pointer array of the Go data type, for example: []*excelize.Options or []*string
                    c_type = get_c_field_type(
                        ctypes_instance, c_field_name
                    )._type_._type_
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (POINTER(c_type) * l)()
                        if is_py_primitive_type(get_args(py_field_type)[0]):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                c_array.__setitem__(
                                    i,
                                    pointer(py_to_base_ctype(py_list[i], c_type)),
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                c_array.__setitem__(
                                    i,
                                    pointer(py_value_to_c(py_list[i], c_type())),
                                )
                        ctypes_instance.__setattr__(c_field_name + "Len", c_int(l))
                        ctypes_instance.__setattr__(c_field_name, c_array)
    return ctypes_instance


def py_value_to_c_interface(py_value):
    """
    Converts a Python value to a C interface representation.

    Args:
        py_value: The Python value to be converted.

    Returns:
        An Interface object representing the Python value in a C-compatible format.

    Raises:
        TypeError: If the type of py_value is not supported.
    """
    type_mappings = {
        int: lambda: Interface(type=1, integer=py_value),
        str: lambda: Interface(type=2, string=py_value),
        float: lambda: Interface(type=3, float64=py_value),
        bool: lambda: Interface(type=4, boolean=py_value),
        datetime: lambda: Interface(type=5, integer=int(py_value.timestamp())),
        date: lambda: Interface(
            type=5,
            integer=int(datetime.combine(py_value, time.min).timestamp()),
        ),
    }
    interface = type_mappings.get(type(py_value), lambda: Interface())()
    return py_value_to_c(interface, types_go._Interface())


class File:
    file_index: int

    def __init__(self, file_index):
        self.file_index = file_index

    def save(self, *opts: Options) -> Optional[Exception]:
        """
        Override the spreadsheet with origin path.

        Args:
            *opts (Options): Optional parameters for saving the file.

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.Save.restype = None, c_char_p
        options = POINTER(types_go._Options)()
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        err = lib.Save(self.file_index, options).decode(ENCODE)
        return None if err == "" else Exception(err)

    def save_as(self, filename: str, *opts: Options) -> Optional[Exception]:
        """
        Create or update to a spreadsheet at the provided path.

        Args:
            filename (str): The name of the file to save.
            *opts (Options): Optional parameters for saving the file.

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SaveAs.restype = c_char_p
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        err = lib.SaveAs(self.file_index, filename.encode(ENCODE), options).decode(
            ENCODE
        )
        return None if err == "" else Exception(err)

    def add_chart(
        self, sheet: str, cell: str, chart: Chart, **combo: Chart
    ) -> Optional[Exception]:
        """
        Add chart in a sheet by given chart format set (such as offset, scale,
        aspect ratio setting and print settings) and properties set.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            chart (Chart): Chart options
            **combo (Chart): Optional parameters for combo chart

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.AddChart.restype = c_char_p
        opts = [chart] + list(combo.values())
        charts = (types_go._Chart * len(opts))()
        for i, opt in enumerate(opts):
            charts[i] = py_value_to_c(opt, types_go._Chart())
        err = lib.AddChart(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(charts),
            len(charts),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_chart_sheet(
        self, sheet: str, chart: Chart, **combo: Chart
    ) -> Optional[Exception]:
        """
        Create a chartsheet by given chart format set (such as offset, scale,
        aspect ratio setting and print settings) and properties set. In Excel a
        chartsheet is a worksheet that only contains a chart.

        Args:
            sheet (str): The worksheet name
            chart (Chart): Chart options
            **combo (Chart): Optional parameters for combo chart

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.AddChartSheet.restype = c_char_p
        opts = [chart] + list(combo.values())
        charts = (types_go._Chart * len(opts))()
        for i, opt in enumerate(opts):
            charts[i] = py_value_to_c(opt, types_go._Chart())
        err = lib.AddChartSheet(
            self.file_index,
            sheet.encode(ENCODE),
            byref(charts),
            len(charts),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_comment(self, sheet: str, opts: Comment) -> Optional[Exception]:
        """
        Add comments in a sheet by giving the worksheet name, cell reference,
        and format set (such as author and text). Note that the maximum author
        name length is 255 and the max text length is 32512.

        Args:
            sheet (str): The worksheet name
            opts (Comment): The comment options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.AddComment.restype = c_char_p
        options = py_value_to_c(opts, types_go._Comment())
        err = lib.AddComment(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_form_control(self, sheet: str, opts: FormControl) -> Optional[Exception]:
        """
        Add form control button in a worksheet by given worksheet name and form
        control options. Supported form control type: button, check box, group
        box, label, option button, scroll bar and spinner. If set macro for the
        form control, the workbook extension should be XLSM or XLTM. Scroll
        value must be between 0 and 30000.

        Args:
            sheet (str): The worksheet name
            opts (FormControl): The form control options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.AddFormControl.restype = c_char_p
        options = py_value_to_c(opts, types_go._FormControl())
        err = lib.AddFormControl(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_picture(
        self, sheet: str, cell: str, name: str, opts: Optional[GraphicOptions]
    ) -> Optional[Exception]:
        """
        Add picture in a sheet by given picture format set (such as offset,
        scale, aspect ratio setting and print settings) and file path, supported
        image types: BMP, EMF, EMZ, GIF, JPEG, JPG, PNG, SVG, TIF, TIFF, WMF,
        and WMZ.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            name (str): The image file path
            *opts (GraphicOptions): The image options

        Returns:
            Optional[GraphicOptions]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.AddPicture.restype = c_char_p
        options = (
            byref(py_value_to_c(opts, types_go._GraphicOptions()))
            if opts
            else POINTER(types_go._GraphicOptions)()
        )
        err = lib.AddPicture(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            name.encode(ENCODE),
            options,
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_pivot_table(self, opts: Optional[PivotTableOptions]) -> Optional[Exception]:
        """
        Add pivot table by given pivot table options. Note that the same fields
        can not in Columns, Rows and Filter fields at the same time.

        Args:
            opts (PivotTableOptions): The pivot table options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.

        Example:
            For example, create a pivot table on the range reference
            Sheet1!G2:M34 with the range reference Sheet1!A1:E31 as the data
            source, summarize by sum for sales:

            .. code-block:: python

            import excelize
            import random

            f = excelize.new_file()
            month = [
                "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
            ]
            year = [2017, 2018, 2019]
            types = ["Meat", "Dairy", "Beverages", "Produce"]
            region = ["East", "West", "North", "South"]
            err = f.set_sheet_row("Sheet1", "A1", ["Month", "Year", "Type", "Sales", "Region"])
            if err:
                print(err)
            for row in range(2, 32):
                err = f.set_cell_value("Sheet1", f"A{row}", month[random.randrange(12)])
                if err:
                    print(err)
                err = f.set_cell_value("Sheet1", f"B{row}", year[random.randrange(3)])
                if err:
                    print(err)
                err = f.set_cell_value("Sheet1", f"C{row}", types[random.randrange(4)])
                if err:
                    print(err)
                err = f.set_cell_value("Sheet1", f"D{row}", random.randrange(5000))
                if err:
                    print(err)
                err = f.set_cell_value("Sheet1", f"E{row}", region[random.randrange(4)])
                if err:
                    print(err)

            err = f.add_pivot_table(
                excelize.PivotTableOptions(
                    data_range="Sheet1!A1:E31",
                    pivot_table_range="Sheet1!G2:M34",
                    rows=[
                        excelize.PivotTableField(data="Month", default_subtotal=True),
                        excelize.PivotTableField(data="Year"),
                    ],
                    filter=[excelize.PivotTableField(data="Region")],
                    columns=[
                        excelize.PivotTableField(data="Type", default_subtotal=True),
                    ],
                    data=[
                        excelize.PivotTableField(data="Sales", name="Summarize", subtotal="Sum"),
                    ],
                    row_grand_totals=True,
                    col_grand_totals=True,
                    show_drill=True,
                    show_row_headers=True,
                    show_col_headers=True,
                    show_last_column=True,
                )
            )
            if err:
                print(err)
            err = f.save_as("Book1.xlsx")
            if err:
                print(err)
            err = f.close()
            if err:
                print(err)
        """
        lib.AddPivotTable.restype = c_char_p
        err = lib.AddPivotTable(
            self.file_index,
            byref(py_value_to_c(opts, types_go._PivotTableOptions())),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_shape(self, sheet: str, opts: Shape) -> Optional[Exception]:
        """
        Add shape in a sheet by given worksheet name and shape format set (such
        as offset, scale, aspect ratio setting and print settings).

        Args:
            sheet (str): The worksheet name
            opts (Shape): The shape options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.

        Example:
            For example, add text box (rect shape) in Sheet1:

            .. code-block:: python

            import excelize

            f = excelize.new_file()
            err = f.add_shape(
                "Sheet1",
                excelize.Shape(
                    cell="G6",
                    type="rect",
                    line=excelize.ShapeLine(
                        color="4286F4",
                        width=1.2,
                    ),
                    fill=excelize.Fill(
                        color=["8EB9FF"],
                        pattern=1,
                    ),
                    paragraph=[
                        excelize.RichTextRun(
                            text="Rectangle Shape",
                            font=excelize.Font(
                                bold=True,
                                italic=True,
                                family="Times New Roman",
                                size=19,
                                color="777777",
                                underline="sng",
                            ),
                        )
                    ],
                    width=80,
                    height=40,
                ),
            )
            if err:
                print(err)
            err = f.save_as("Book1.xlsx")
            if err:
                print(err)
            err = f.close()
            if err:
                print(err)
        """
        lib.AddShape.restype = c_char_p
        options = py_value_to_c(opts, types_go._Shape())
        err = lib.AddShape(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_slicer(self, sheet: str, opts: SlicerOptions) -> Optional[Exception]:
        """
        Inserts a slicer by giving the worksheet name and slicer settings.

        Args:
            sheet (str): The worksheet name
            opts (SlicerOptions): The slicer options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.

        Example:
            For example, insert a slicer on the Sheet1!E1 with field Column1 for
            the table named Table1:

            .. code-block:: python

            err = f.add_slicer(
                "Sheet1",
                excelize.SlicerOptions(
                    name="Column1",
                    cell="E1",
                    table_sheet="Sheet1",
                    table_name="Table1",
                    caption="Column1",
                    width=200,
                    height=200,
                ),
            )
        """
        lib.AddSlicer.restype = c_char_p
        options = py_value_to_c(opts, types_go._SlicerOptions())
        err = lib.AddSlicer(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_sparkline(self, sheet: str, opts: SparklineOptions) -> Optional[Exception]:
        """
        add sparklines to the worksheet by given formatting options. Sparklines
        are small charts that fit in a single cell and are used to show trends
        in data. Sparklines are a feature of Excel 2010 and later only. You can
        write them to workbook that can be read by Excel 2007, but they won't be
        displayed.

        Args:
            sheet (str): The worksheet name
            opts (SparklineOptions): The sparklines options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.

        Example:
            For example, add a grouped sparkline. Changes are applied to all
            three:

            .. code-block:: python

            err = f.add_sparkline(
                "Sheet1",
                excelize.SparklineOptions(
                    location=["A1", "A2", "A3"],
                    range=["Sheet2!A1:J1", "Sheet2!A2:J2", "Sheet2!A3:J3"],
                    markers=True,
                ),
            )
        """
        lib.AddSparkline.restype = c_char_p
        options = py_value_to_c(opts, types_go._SparklineOptions())
        err = lib.AddSparkline(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def add_table(self, sheet: str, table: Table) -> Optional[Exception]:
        """
        Add table in a worksheet by given worksheet name, range reference and
        format set.

        Note that the table must be at least two lines including the header. The
        header cells must contain strings and must be unique, and must set the
        header row data of the table before calling the AddTable function.
        Multiple tables range reference that can't have an intersection.

        Args:
            sheet (str): The worksheet name
            table (Table): The table options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.

        Example:
            For example, create a table of A1:D5 on Sheet1:

            .. code-block:: python

            err = f.add_table("Sheet1", excelize.Table(range="A1:D5"))
        """
        lib.AddTable.restype = c_char_p
        options = py_value_to_c(table, types_go._Table())
        err = lib.AddTable(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def auto_filter(
        self,
        sheet: str,
        range_ref: str,
        opts: List[AutoFilterOptions],
    ) -> Optional[Exception]:
        """
        Add auto filter in a worksheet by given worksheet name, range reference
        and settings. An auto filter in Excel is a way of filtering a 2D range
        of data based on some simple criteria.

        Column defines the filter columns in an auto filter range based on simple
        criteria

        It isn't sufficient to just specify the filter condition. You must also
        hide any rows that don't match the filter condition. Rows are hidden using
        the SetRowVisible function. Excelize can't filter rows automatically since
        this isn't part of the file format.

        Args:
            sheet (str): The worksheet name
            range_ref (str): The top-left and right-bottom cell range reference
            opts (List[AutoFilterOptions]): The auto filter options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.AutoFilter.restype = c_char_p
        options = (types_go._AutoFilterOptions * len(opts))()
        for i, opt in enumerate(opts):
            options[i] = py_value_to_c(opt, types_go._AutoFilterOptions())
        err = lib.AutoFilter(
            self.file_index,
            sheet.encode(ENCODE),
            range_ref.encode(ENCODE),
            byref(options),
            len(options),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def calc_cell_value(
        self, sheet: str, cell: str, *opts: Options
    ) -> Tuple[str, Optional[Exception]]:
        """
        Get calculated cell value. This feature is currently in working
        processing. Iterative calculation, implicit intersection, explicit
        intersection, array formula, table formula and some other formulas are
        not supported currently.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            *opts (Options): Optional parameters for get cell value

        Returns:
            Tuple[str, Optional[Exception]]: A tuple containing the calculation
            result as a string and an exception if an error occurred, otherwise
            None.
        """
        lib.CalcCellValue.restype = types_go._CalcCellValueResult
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.CalcCellValue(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE), options
        )
        err = res.err.decode(ENCODE)
        return res.val.decode(ENCODE), None if err == "" else Exception(err)

    def close(self) -> Optional[Exception]:
        """
        Closes and cleanup the open temporary file for the spreadsheet.

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.Close.restype = None, c_char_p
        err = lib.Close(self.file_index).decode(ENCODE)
        return None if err == "" else Exception(err)

    def copy_sheet(self, src: int, to: int) -> Optional[Exception]:
        """
        Duplicate a worksheet by gave source and target worksheet index. Note
        that currently doesn't support duplicate workbooks that contain tables,
        charts or pictures.

        Args:
            src (int): Source sheet index
            to (int): Target sheet index

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.CopySheet.restype = None, c_char_p
        err = lib.CopySheet(self.file_index, src, to).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_chart(self, sheet: str, cell: str) -> Optional[Exception]:
        """
        Delete chart in spreadsheet by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteChart.restype = None, c_char_p
        err = lib.DeleteChart(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_comment(self, sheet: str, cell: str) -> Optional[Exception]:
        """
        Delete comment in a worksheet by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteComment.restype = None, c_char_p
        err = lib.DeleteComment(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_picture(self, sheet: str, cell: str) -> Optional[Exception]:
        """
        Delete all pictures in a cell by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeletePicture.restype = None, c_char_p
        err = lib.DeletePicture(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_sheet(self, sheet: str) -> Optional[Exception]:
        """
        Delete worksheet in a workbook by given worksheet name. Use this method
        with caution, which will affect changes in references such as formulas,
        charts, and so on. If there is any referenced value of the deleted
        worksheet, it will cause a file error when you open it. This function
        will be invalid when only one worksheet is left.

        Args:
            sheet (str): The worksheet name

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteSheet.restype = None, c_char_p
        err = lib.DeleteSheet(self.file_index, sheet.encode(ENCODE)).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_slicer(self, name: str) -> Optional[Exception]:
        """
        Delete a slicer by a given slicer name.

        Args:
            name (str): The slicer name

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteSlicer.restype = None, c_char_p
        err = lib.DeleteSlicer(self.file_index, name.encode(ENCODE)).decode(ENCODE)
        return None if err == "" else Exception(err)

    def duplicate_row(self, sheet: str, row: int) -> Optional[Exception]:
        """
        Inserts a copy of specified row (by its Excel row number) below. Use
        this method with caution, which will affect changes in references such
        as formulas, charts, and so on. If there is any referenced value of the
        worksheet, it will cause a file error when you open it. The excelize
        only partially updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DuplicateRow.restype = None, c_char_p
        err = lib.DuplicateRow(self.file_index, sheet.encode(ENCODE), row).decode(
            ENCODE
        )
        return None if err == "" else Exception(err)

    def duplicate_row_to(self, sheet: str, row: int, row2: int) -> Optional[Exception]:
        """
        Inserts a copy of specified row by it Excel number to specified row
        position moving down exists rows after target position. Use this method
        with caution, which will affect changes in references such as formulas,
        charts, and so on. If there is any referenced value of the worksheet, it
        will cause a file error when you open it. The excelize only partially
        updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number
            row2 (int): The row number

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DuplicateRowTo.restype = None, c_char_p
        err = lib.DuplicateRowTo(
            self.file_index, sheet.encode(ENCODE), row, row2
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def get_active_sheet_index(self) -> int:
        """
        Get active sheet index of the spreadsheet. If not found the active sheet
        will be return integer 0.

        Returns:
            int: The active sheet index
        """
        lib.GetActiveSheetIndex.restype = c_int
        res = lib.GetActiveSheetIndex(self.file_index)
        return res

    def get_app_props(
        self,
    ) -> Tuple[Optional[AppProperties], Optional[Exception]]:
        """
        Get document application properties.

        Returns:
            Tuple[Optional[AppProperties], Optional[Exception]]: A tuple
            containing the app properties if found, otherwise None, and an
            Exception object if an error occurred, otherwise None.
        """
        lib.GetAppProps.restype = types_go._GetAppPropsResult
        res = lib.GetAppProps(self.file_index)
        err = res.err.decode(ENCODE)
        return (c_value_to_py(res.opts, AppProperties()) if err == "" else None), (
            None if err == "" else Exception(err)
        )

    def get_cell_formula(
        self, sheet: str, cell: str
    ) -> Tuple[str, Optional[Exception]]:
        """
        Get formula from cell by given worksheet name and cell reference in
        spreadsheet.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Tuple[str, Optional[Exception]]: A tuple containing the cell formula
            string and an exception if an error occurred, otherwise None.
        """
        lib.GetCellFormula.restype = types_go._GetCellFormulaResult
        res = lib.GetCellFormula(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        )
        err = res.err.decode(ENCODE)
        return res.val.decode(ENCODE), None if err == "" else Exception(err)

    def get_cell_hyperlink(
        self, sheet: str, cell: str
    ) -> Tuple[bool, str, Optional[Exception]]:
        """
        Gets a cell hyperlink based on the given worksheet name and cell
        reference. If the cell has a hyperlink, it will return `True` and the
        link address, otherwise it will return `False` and an empty link address.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Tuple[bool, str, Optional[Exception]]: A tuple containing if the
            cell has a hyperlink, the link address, and an exception if an error
            occurred, otherwise None.

        Example:
            For example, get a hyperlink to a `H6` cell on a worksheet named
            `Sheet1`:

            .. code-block:: python

            link, target, err = f.get_cell_hyperlink("Sheet1", "H6")
        """
        lib.GetCellHyperLink.restype = types_go._GetCellHyperLinkResult
        res = lib.GetCellHyperLink(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        )
        err = res.err.decode(ENCODE)
        return (
            res.link,
            res.target.decode(ENCODE),
            None if err == "" else Exception(err),
        )

    def get_cell_value(
        self, sheet: str, cell: str, *opts: Options
    ) -> Tuple[str, Optional[Exception]]:
        """
        Get formatted value from cell by given worksheet name and cell reference
        in spreadsheet. The return value is converted to the 'string' data type.
        This function is concurrency safe. If the cell format can be applied to
        the value of a cell, the applied value will be returned, otherwise the
        original value will be returned. All cells' values will be the same in a
        merged range.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            *opts (Options): Optional parameters for get cell value

        Returns:
            Tuple[str, Optional[Exception]]: A tuple containing the cell value
            as a string and an exception if an error occurred, otherwise None.
        """
        lib.GetCellValue.restype = types_go._GetCellValueResult
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.GetCellValue(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE), options
        )
        err = res.err.decode(ENCODE)
        return res.val.decode(ENCODE), None if err == "" else Exception(err)

    def get_rows(
        self, sheet: str, *opts: Options
    ) -> Tuple[List[List[str]], Optional[Exception]]:
        """
        Return all the rows in a sheet by given worksheet name, returned as a
        two-dimensional array, where the value of the cell is converted to the
        string type. If the cell format can be applied to the value of the cell,
        the applied value will be used, otherwise the original value will be
        used. GetRows fetched the rows with value or formula cells, the
        continually blank cells in the tail of each row will be skipped, so the
        length of each row may be inconsistent.

        Args:
            sheet (str): The worksheet name
            *opts (Options): Optional parameters for get rows

        Returns:
            Tuple[List[List[str]], Optional[Exception]]: A tuple containing the
            cell value as a string and an exception if an error occurred,
            otherwise None.
        """
        lib.GetRows.restype = types_go._GetRowsResult
        rows = []
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.GetRows(self.file_index, sheet.encode(ENCODE), options)
        err = res.err.decode(ENCODE)
        result = c_value_to_py(res, GetRowsResult()).row

        if result:
            for row in result:
                if row.cell:
                    rows.append([cell for cell in row.cell])

        return rows, None if err == "" else Exception(err)

    def get_style(self, style_id: int) -> Tuple[Optional[Style], Optional[Exception]]:
        """
        Get style definition by given style index.

        Args:
            style_id (int): The style ID

        Returns:
            Tuple[Optional[Style], Optional[Exception]]: A tuple containing the
            Style object if found, otherwise None, and an Exception object if an
            error occurred, otherwise None.
        """
        lib.GetStyle.restype = types_go._GetStyleResult
        res = lib.GetStyle(self.file_index, c_int(style_id))
        err = res.err.decode(ENCODE)
        if err == "":
            return c_value_to_py(res.style, Style()), None
        return None, Exception(err)

    def merge_cell(
        self, sheet: str, top_left_cell: str, bottom_right_cell: str
    ) -> Optional[Exception]:
        """
        Merge cells by given range reference and sheet name. Merging cells only
        keeps the upper-left cell value, and discards the other values.

        Args:
            sheet (str): The worksheet name
            top_left_cell (str): The top-left cell reference
            bottom_right_cell (str): The right-bottom cell reference

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.MergeCell.restype = c_char_p
        err = lib.MergeCell(
            self.file_index,
            sheet.encode(ENCODE),
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def new_sheet(self, sheet: str) -> Tuple[int, Optional[Exception]]:
        """
        Create a new sheet by given a worksheet name and returns the index of
        the sheets in the workbook after it appended. Note that when creating a
        new workbook, the default worksheet named `Sheet1` will be created.

        Args:
            sheet (str): The worksheet name

        Returns:
            Tuple[int, Optional[Exception]]: A tuple containing the index of the
            new sheet and an Exception if an error occurred, otherwise None.
        """
        lib.NewSheet.restype = types_go._NewSheetResult
        res = lib.NewSheet(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        return res.idx, None if err == "" else Exception(err)

    def new_style(self, style: Style) -> Tuple[int, Optional[Exception]]:
        """
        Create the style for cells by a given style options, and returns style
        index. The same style index can not be used across different workbook.
        This function is concurrency safe. Note that the 'Font.Color' field uses
        an RGB color represented in 'RRGGBB' hexadecimal notation.

        Args:
            style (Style): The style options

        Returns:
            Tuple[int, Optional[Exception]]: A tuple containing the style index
            and an exception if any error occurs.
        """
        lib.NewStyle.restype = types_go._NewStyleResult
        options = py_value_to_c(style, types_go._Style())
        res = lib.NewStyle(self.file_index, byref(options))
        err = res.err.decode(ENCODE)
        return res.style, None if err == "" else Exception(err)

    def set_active_sheet(self, index: int) -> Optional[Exception]:
        """
        Set the default active sheet of the workbook by a given index. Note that
        the active index is different from the ID returned by function
        get_sheet_map. It should be greater than or equal to 0 and less than the
        total worksheet numbers.

        Parameters:
        index (int): The sheet index

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.SetActiveSheet.restype = None, c_char_p
        err = lib.SetActiveSheet(self.file_index, index).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_formula(
        self, sheet: str, cell: str, formula: str, *opts: FormulaOpts
    ) -> Optional[Exception]:
        """
        Set formula on the cell is taken according to the given worksheet name
        and cell formula settings. The result of the formula cell can be
        calculated when the worksheet is opened by the Office Excel application
        or can be using the "CalcCellValue" function also can get the calculated
        cell value. If the Excel application doesn't calculate the formula
        automatically when the workbook has been opened, please call
        "update_linked_value" after setting the cell formula functions.

        Parameters:
        sheet (str): The worksheet name
        cell (str): The cell reference
        formula (str): The cell formula
        *opts (FormulaOpts): The formula options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.SetCellFormula.restype = None, c_char_p
        options = (
            byref(py_value_to_c(opts[0], types_go._FormulaOpts()))
            if opts
            else POINTER(types_go._FormulaOpts)()
        )
        err = lib.SetCellFormula(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            formula.encode(ENCODE),
            options,
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_hyperlink(
        self,
        sheet: str,
        cell: str,
        link: str,
        link_type: str,
        *opts: HyperlinkOpts,
    ) -> Optional[Exception]:
        """
        Set cell hyperlink by given worksheet name and link URL address. The
        `link_type` defines three types of hyperlink "External" for website or
        "Location" for moving to one of cell in this workbook or "None" for
        remove hyperlink. Maximum limit hyperlinks in a worksheet is 65530.
        This function is only used to set the hyperlink of the cell and doesn't
        affect the value of the cell. If you need to set the value of the cell
        please use the other functions such as `set_cell_style` or
        `set_sheet_row`.

        Parameters:
        sheet (str): The worksheet name
        cell (str): The cell reference
        link (str): The hyperlink
        link_type (str): The hyperlink type
        *opts (HyperlinkOpts): The hyperlink options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.

        Example:
            The below is example for external link.

            .. code-block:: python

            display = "https://github.com/xuri/excelize"
            err = f.set_cell_hyperlink(
                "Sheet1",
                "A3",
                display,
                "External",
                excelize.HyperlinkOpts(display=display, tooltip="Excelize on GitHub"),
            )
            if err:
                print(err)
            # Set underline and font color style for the cell.
            style, err = f.new_style(
                excelize.Style(
                    font=excelize.Font(color="1265BE", underline="single")
                )
            )
            if err:
                print(err)
            err = f.set_cell_style("Sheet1", "A3", "A3", style)
        """
        err, lib.SetCellHyperLink.restype = None, c_char_p
        options = (
            byref(py_value_to_c(opts[0], types_go._HyperlinkOpts()))
            if opts
            else POINTER(types_go._HyperlinkOpts)()
        )
        err = lib.SetCellHyperLink(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            link.encode(ENCODE),
            link_type.encode(ENCODE),
            options,
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_style(
        self,
        sheet: str,
        top_left_cell: str,
        bottom_right_cell: str,
        style_id: int,
    ) -> Optional[Exception]:
        """
        Add style attribute for cells by given worksheet name, range reference
        and style ID. Note that diagonalDown and diagonalUp type border should
        be use same color in the same range. SetCellStyle will overwrite the
        existing styles for the cell, it won't append or merge style with
        existing styles.

        Args:
            sheet (str): The worksheet name
            top_left_cell (str): The top-left cell reference
            bottom_right_cell (str): The right-bottom cell reference
            style_id (int): The style ID

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetCellStyle.restype = c_char_p
        err = lib.SetCellStyle(
            self.file_index,
            sheet.encode(ENCODE),
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
            style_id,
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_value(
        self,
        sheet: str,
        cell: str,
        value: Union[None, int, str, bool, datetime, date],
    ) -> Optional[Exception]:
        """
        Set the value of a cell. The specified coordinates should not be in the
        first row of the table, a complex number can be set with string text.

        Note that default date format is m/d/yy h:mm of time.Time type value.
        You can set numbers format by the SetCellStyle function. If you need to
        set the specialized date in Excel like January 0, 1900 or February 29,
        1900, these times can not representation in Go language time.Time data
        type. Please set the cell value as number 0 or 60, then create and bind
        the date-time number format style for the cell.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            value (Union[None, int, str, bool, datetime, date]): The cell value
            to be write

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetCellValue.restype = c_char_p
        err = lib.SetCellValue(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(py_value_to_c_interface(value)),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_background(self, sheet: str, picture: str) -> Optional[Exception]:
        """
        Set background picture by given worksheet name and file path. Supported
        image types: BMP, EMF, EMZ, GIF, JPEG, JPG, PNG, SVG, TIF, TIFF, WMF,
        and WMZ.

        Args:
            sheet (str): The worksheet name
            picture (str): The image file path

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetSheetBackground.restype = c_char_p
        err = lib.SetSheetBackground(
            self.file_index,
            sheet.encode(ENCODE),
            picture.encode(ENCODE),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_background_from_bytes(
        self, sheet: str, extension: str, picture: bytes
    ) -> Optional[Exception]:
        """
        Set background picture by given worksheet name, extension name and image
        data. Supported image types: BMP, EMF, EMZ, GIF, JPEG, JPG, PNG, SVG,
        TIF, TIFF, WMF, and WMZ.

        Args:
            sheet (str): The worksheet name
            extension (str): The image extension
            picture (bytes): The contents buffer of the file

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetSheetBackgroundFromBytes.restype = c_char_p
        err = lib.SetSheetBackgroundFromBytes(
            self.file_index,
            sheet.encode(ENCODE),
            extension.encode(ENCODE),
            cast(picture, POINTER(c_ubyte)),
            len(picture),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_row(
        self,
        sheet: str,
        cell: str,
        values: List[Union[None, int, str, bool, datetime, date]],
    ) -> Optional[Exception]:
        """
        Writes cells to row by given worksheet name, starting cell reference and
        cell values list.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            values (List[Union[None, int, str, bool, datetime, date]]): The cell
            values

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetSheetRow.restype = c_char_p
        vals = (types_go._Interface * len(values))()
        for i, value in enumerate(values):
            vals[i] = py_value_to_c_interface(value)
        err = lib.SetSheetRow(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(vals),
            len(vals),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_view(
        self, sheet: str, view_index: int, opts: ViewOptions
    ) -> Optional[Exception]:
        """
        Sets sheet view options. The viewIndex may be negative and if so is
        counted backward (-1 is the last view).

        Args:
            sheet (str): The worksheet name
            view_index (int): The sheet view index
            opts (ViewOptions): The sheet view options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetSheetView.restype = c_char_p
        options = py_value_to_c(opts, types_go._ViewOptions())
        err = lib.SetSheetView(
            self.file_index, sheet.encode(ENCODE), view_index, byref(options)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_visible(
        self, sheet: str, visible: bool, *very_hidden: bool
    ) -> Optional[Exception]:
        """
        Set worksheet visible by given worksheet name. A workbook must contain
        at least one visible worksheet. If the given worksheet has been
        activated, this setting will be invalidated. The third optional
        very_hidden parameter only works when visible was false.

        Args:
            sheet (str): The worksheet name
            visible (bool): The worksheet visibility
            *very_hidden (bool): Optional boolean very hidden parameter

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetSheetVisible.restype = c_char_p
        vh = False
        if len(very_hidden) > 0:
            vh = very_hidden[0]
        err = lib.SetSheetVisible(
            self.file_index, sheet.encode(ENCODE), visible, vh
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_workbook_props(self, opts: WorkbookPropsOptions) -> Optional[Exception]:
        """
        Sets workbook properties.

        Args:
            opts (WorkbookPropsOptions): TThe workbook property options

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetWorkbookProps.restype = c_char_p
        options = py_value_to_c(opts, types_go._WorkbookPropsOptions())
        err = lib.SetWorkbookProps(self.file_index, byref(options)).decode(ENCODE)
        return None if err == "" else Exception(err)


def cell_name_to_coordinates(cell: str) -> Tuple[int, int, Optional[Exception]]:
    """
    Converts alphanumeric cell name to [X, Y] coordinates or returns an error.

    Args:
        cell (str): The cell reference

    Returns:
        Tuple[int, int, Optional[Exception]]: A tuple containing the column
        number, row number, and an Exception if an error occurred, otherwise None.
    """
    lib.CellNameToCoordinates.restype = types_go._CellNameToCoordinatesResult
    res = lib.CellNameToCoordinates(cell.encode(ENCODE))
    err = res.err.decode(ENCODE)
    return res.col, res.row, None if err == "" else Exception(err)


def column_name_to_number(name: str) -> Tuple[int, Optional[Exception]]:
    """
    Convert Excel sheet column name (case-insensitive) to int. The function
    returns an error if column name incorrect.

    Args:
        name (str): The column name

    Returns:
        Tuple[int, Optional[Exception]]: A tuple containing the column number
        and an Exception if an error occurred, otherwise None.
    """
    lib.ColumnNameToNumber.restype = types_go._ColumnNameToNumberResult
    res = lib.ColumnNameToNumber(name.encode(ENCODE))
    err = res.err.decode(ENCODE)
    return res.col, None if err == "" else Exception(err)


def column_number_to_name(num: int) -> Tuple[str, Optional[Exception]]:
    """
    Convert the integer to Excel sheet column title.

    Args:
        num (int): The column number

    Returns:
        Tuple[str, Optional[Exception]]: A tuple containing the column name and
        an Exception if an error occurred, otherwise None.
    """
    lib.ColumnNumberToName.restype = types_go._ColumnNumberToNameResult
    res = lib.ColumnNumberToName(c_int(num))
    err = res.err.decode(ENCODE)
    return res.col.decode(ENCODE), None if err == "" else Exception(err)


def coordinates_to_cell_name(
    col: int, row: int, *abs: bool
) -> Tuple[str, Optional[Exception]]:
    """
    Converts [X, Y] coordinates to alpha-numeric cell name or returns an error.

    Args:
        col (int): The column number.
        row (int): The row number.
        *abs (bool): Optional boolean indicating whether to use absolute
        references. If provided and True, the cell name will use absolute
        references (e.g., $A$1).

    Returns:
        Tuple[str, Optional[Exception]]: A tuple containing the cell name as a
        string and an Exception if an error occurred, otherwise None.
    """
    lib.CoordinatesToCellName.restype = types_go._CoordinatesToCellNameResult
    options = False
    if len(abs) > 0:
        options = abs[0]
    res = lib.CoordinatesToCellName(col, row, options)
    err = res.err.decode(ENCODE)
    return res.cell.decode(ENCODE), None if err == "" else Exception(err)


def new_file() -> File:
    """
    Create new file by default template.

    Returns:
        File: A populated spreadsheet file struct.
    """
    return File(lib.NewFile())


def open_file(
    filename: str, *opts: Options
) -> Tuple[Optional[File], Optional[Exception]]:
    """
    OpenFile take the name of a spreadsheet file and returns a populated
    spreadsheet file struct for it.

    Args:
        filename (str): The path to the Excel file to open.
        *opts (Options): Optional parameters for opening the file.

    Returns:
        Tuple[Optional[File], Optional[Exception]]: A tuple containing a File
        object if successful, or None and an Exception if an error occurred.
    """
    lib.OpenFile.restype, options = types_go._OptionsResult, None
    if len(opts) > 0:
        options = byref(py_value_to_c(opts[0], types_go._Options()))
    res = lib.OpenFile(filename.encode(ENCODE), options)
    err = res.err.decode(ENCODE)
    if err == "":
        return File(res.idx), None
    return None, Exception(err)


def open_reader(
    buffer: bytes, *opts: Options
) -> Tuple[Optional[File], Optional[Exception]]:
    """
    Read data stream from bytes and return a populated spreadsheet file.

    Args:
        buffer (bytes): The contents buffer of the file
        *opts (Options): Optional parameters for opening the file.

    Returns:
        Tuple[Optional[File], Optional[Exception]]: A tuple containing a File
        object if successful, or None and an Exception if an error occurred.
    """
    lib.OpenReader.restype, options = types_go._OptionsResult, None
    if len(opts) > 0:
        options = byref(py_value_to_c(opts[0], types_go._Options()))
    res = lib.OpenReader(cast(buffer, POINTER(c_ubyte)), len(buffer), options)
    err = res.err.decode(ENCODE)
    if err == "":
        return File(res.idx), None
    return None, Exception(err)
